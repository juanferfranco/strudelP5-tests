<!DOCTYPE html>
<html>
<head>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <style> body { margin: 0; overflow: hidden; background: black; } </style>
</head>
<body>
<script>


  let eventQueue = [];
  let diametroBD = 0;
  let diametroSD = 0;
  let diametroHH = 0;
  let diametroOH = 0;


  let lastDelta = 0; // Para medir la precisión
  let history = [];  // Para ver el historial de precisión

  function setup() {
    createCanvas(windowWidth, windowHeight);
    noStroke();
    frameRate(60);
    textSize(32);

    const socket = new WebSocket('ws://localhost:8081');
    socket.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        console.log('Mensaje OSC recibido:', msg);
        let params = {};
        for (let i = 0; i < msg.args.length; i += 2) {
            params[msg.args[i]] = msg.args[i+1];
        }
        eventQueue.push({ timestamp: msg.timestamp, params: params });
        eventQueue.sort((a, b) => a.timestamp - b.timestamp);
    };
  }

  function draw() {
    background(0, 30); // Estela más larga para ver mejor el movimiento
    let now = Date.now();

    // --- LÓGICA DE DIAGNÓSTICO GRÁFICO ---
    drawDebugTimeline(now);

    // --- PROCESAMIENTO DE EVENTOS ---
    while (eventQueue.length > 0 && now >= eventQueue[0].timestamp) {
        let ev = eventQueue.shift();
        
        // Calculamos el error de sincronía (0 sería perfecto)
        lastDelta = now - ev.timestamp; 
        history.push(lastDelta);
        if(history.length > 50) history.shift();

        ejecutarVisual(ev.params);
    }    

    // --- VISUAL PRINCIPAL ---
    if (diametroBD > 0) {
        fill(255, 0, 100);
        circle(width/2, height/2, diametroBD);
        diametroBD *= 0.85;
    }
    
    if (diametroSD > 0) {
        fill(0, 255, 100);
        circle(width/2, height/2-(height/2)/2, diametroSD);
        diametroSD *= 0.85;
    }
    if (diametroHH > 0) {
        fill(100, 100, 255);
        circle(width/2-(width/2)/2, height/2, diametroHH);
        diametroHH *= 0.85;
    }
    if (diametroOH > 0) {
        fill(255, 255, 100);
        circle(width/2+(width/2)/2, height/2, diametroOH);
        diametroOH *= 0.85;
    }

    


    // --- TEXTO DE DEBUG ---
    fill(255);
    textAlign(LEFT);
    text(`Último error de sincronía: ${lastDelta.toFixed(2)} ms`, 20, 50);
    text(`FPS: ${Math.round(frameRate())}`, 20, 90);
  }

  function drawDebugTimeline(now) {
    push();
    translate(0, height - 200);
    
    // Línea de "AHORA" (el punto crítico)
    stroke(255, 0, 0);
    line(width / 2, 0, width / 2, 80);
    noStroke();
    fill(255, 0, 0);
    text("AHORA", width / 2 + 5, 15);

    // Dibujar eventos futuros que vienen en camino
    // Rango de visualización: 1 segundo (500ms antes y después)
    let escala = 0.5; // pixeles por milisegundo
    
    eventQueue.forEach(ev => {
        let x = width / 2 + (ev.timestamp - now) * escala;
        fill(0, 255, 255);
        ellipse(x, 40, 20, 20);
    });

    // Dibujar historial de precisión (puntos blancos)
    // Si los puntos están a la derecha de la línea roja, vas tarde.
    history.forEach((d, i) => {
        fill(255, 255, 255, i * 5);
        ellipse(width / 2 + d * escala, 60, 10, 10);
    });
    pop();
  }
  
  function ejecutarVisual(p) {
    if (p.s === 'tr909bd') { diametroBD = 300; }
    if (p.s === 'tr909sd') { diametroSD = 300; }
    if (p.s === 'tr909hh') { diametroHH = 300; }
    if (p.s === 'tr909oh') { diametroOH = 300; }
  }

  function windowResized() { resizeCanvas(windowWidth, windowHeight); }


</script>
</body>
</html>